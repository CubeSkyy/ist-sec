package com.dpas.server;

/* these are generated by the hello-world-server contract */

import com.dpas.HelloWorld;
import com.dpas.HelloWorldServiceGrpc;
import com.dpas.crypto.Main;
import io.grpc.Grpc;
import io.grpc.Status;
import io.grpc.stub.StreamObserver;
import org.apache.commons.lang3.RandomStringUtils;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.Timer;

import com.dpas.HelloWorld.Announcement;
import com.dpas.HelloWorld.HelloRequest;
import com.dpas.HelloWorld.HelloResponse;
import com.dpas.HelloWorld.GetTokenRequest;
import com.dpas.HelloWorld.GetTokenResponse;
import com.dpas.HelloWorld.PostRequest;
import com.dpas.HelloWorld.PostResponse;
import com.dpas.HelloWorld.PostGeneralRequest;
import com.dpas.HelloWorld.PostGeneralResponse;
import com.dpas.HelloWorld.ReadRequest;
import com.dpas.HelloWorld.ReadResponse;
import com.dpas.HelloWorld.ReadGeneralRequest;
import com.dpas.HelloWorld.ReadGeneralResponse;
import com.google.protobuf.ByteString;
import org.apache.commons.lang3.ArrayUtils;

import java.security.*;
import java.security.cert.CertificateException;

public class HelloWorldServiceImpl extends HelloWorldServiceGrpc.HelloWorldServiceImplBase {

    //TODO: Verify Tokens
    //TODO: Make All Server Responses Signed so client can verify it was server that sent them

    public static HelloWorldServiceImpl instance = null;
    private HashMap<String, String> usersMap;
    private HashMap<String, ArrayList<Announcement>> particularMap;
    private ArrayList<Announcement> generalMap;
    private int postId;
    /*--------------------------------------------------FILES---------------------------------------------------------*/
    public static final String USERS_FILE = "users.tmp";
    public static final String PARTICULAR_FILE = "particular.tmp";
    public static final String GENERAL_FILE = "general.tmp";
    public static final String POSTID_FILE = "postid.tmp";
    public static final String MSG_USERS = "Users successfully read/written to file.";
    public static final String MSG_PARTICULAR = "Particular post successfully read/written to file.";
    public static final String MSG_GENERAL = "General post successfully read/written to file.";
    public static final String MSG_POSTID = "Current post ID successfully read/written to file.";


    public static HelloWorldServiceImpl getInstance() {
        if (instance == null) {

            instance = new HelloWorldServiceImpl();
        }
        return instance;
    }


    private HelloWorldServiceImpl() {
        checkFile(USERS_FILE);
        usersMap = (HashMap<String, String>) readFromFile(USERS_FILE, MSG_USERS);

        checkFile(PARTICULAR_FILE);
        particularMap = (HashMap<String, ArrayList<Announcement>>) readFromFile(PARTICULAR_FILE, MSG_PARTICULAR);

        checkFile(GENERAL_FILE);
        generalMap = (ArrayList<Announcement>) readFromFile(GENERAL_FILE, MSG_GENERAL);


        checkFile(POSTID_FILE);
        postId = (Integer) readFromFile(POSTID_FILE, MSG_POSTID);
    }


    private HashMap<String, String> getUsersMap() {
        return usersMap;
    }

    private HashMap<String, ArrayList<Announcement>> getParticularMap() {
        return particularMap;
    }

    private ArrayList<Announcement> getGeneralMap() {
        return generalMap;
    }

    private int getPostId() {
        return postId;
    }


    public void checkFile(String filename) {

        File f = new File(filename);
        System.out.println("File " + filename + " exists: " + f.isFile());

        if (!f.isFile()) {
            try {
                f.createNewFile();
                switch (filename) {
                    case USERS_FILE:
                        writeToFile(new HashMap<String, String>(), USERS_FILE, MSG_USERS);
                        break;

                    case PARTICULAR_FILE:
                        writeToFile(new HashMap<String, ArrayList<Announcement>>(), PARTICULAR_FILE, MSG_PARTICULAR);
                        break;

                    case GENERAL_FILE:
                        writeToFile(new ArrayList<Announcement>(), GENERAL_FILE, MSG_GENERAL);
                        break;

                    case POSTID_FILE:
                        writeToFile(0, POSTID_FILE, MSG_POSTID);
                        break;

                    default:
                        System.err.println("Invalid filename. Could not write to file.");
                        break;
                }

                System.out.println("" + filename + " file not found. New instance has been created.");

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void writeToFile(Object users, String type, String msg) {

        try {
            FileOutputStream fos = new FileOutputStream(type + "Backup");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(users);
            System.out.println(msg);
            oos.close();
            Files.move(Paths.get(type + "Backup"), Paths.get(type), StandardCopyOption.ATOMIC_MOVE);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public Object readFromFile(String type, String msg) {

        try {
            FileInputStream fis = new FileInputStream(type);
            ObjectInputStream ois = new ObjectInputStream(fis);
            Object users = ois.readObject();
            System.out.println(msg);
            ois.close();
            return users;

        } catch (Exception e) {
            e.printStackTrace();
        }
        return new Object();
    }

    /*-------------------------------------------------GREETING-------------------------------------------------------*/
    @Override
    public void greeting(HelloRequest request, StreamObserver<HelloResponse> responseObserver) {
        System.out.println(request);

        HelloResponse response = HelloResponse.newBuilder()
                .setGreeting("Hello " + request.getName()).build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    /*---------------------------------------------------TOKENS-------------------------------------------------------*/
    @Override
    public synchronized void getToken(GetTokenRequest request, StreamObserver<GetTokenResponse> responseObserver) {
        System.out.println("Get Token Request Received: " + request);

        String key = request.getKey();

        /*--------------------------SIGNATURE AND HASH FROM USER----------------------------*/
        ByteString tokenSigByteString = request.getSignature();
        ByteString tokenHashByteString = request.getHash();

        byte[] tokenSig = tokenSigByteString.toByteArray();
        byte[] tokenHash = tokenHashByteString.toByteArray();

        try {
            byte[] keyHash = Main.getHashFromObject(key);
            boolean valid = Main.validate(tokenSig, key, keyHash, tokenHash); //key == userAlias
            if(!valid){
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid signature and/or hash. GetToken request denied.");
                responseObserver.onError(status.asRuntimeException());
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        /*----------------------------------------------------------------------------------*/

        if (!Main.hasCertificate(key)) { //key == userAlias
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("User is not registered in keystore.");
            responseObserver.onError(status.asRuntimeException());
        }

        /*if (!getUsersMap().containsKey(key)) {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("User is not registered");
            responseObserver.onError(status.asRuntimeException());
        }*/

        String token = RandomStringUtils.randomAlphanumeric(10);

        getUsersMap().replace(key, token);
        writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);

        System.out.println("Users: " + usersMap);

        /*---------------------------SIGNATURE AND HASH FROM SERVER-------------------------*/

        try {
            byte[] hashServer = Main.getHashFromObject(token);
            byte[] sigServer = Main.getSignature(hashServer, "server1"); //TODO change to serverAlias when we have multiple servers

            ByteString sigServerByteString = ByteString.copyFrom(sigServer);
            ByteString hashServerByteString = ByteString.copyFrom(hashServer);

            /*----------------------------------------------------------------------------------*/

            GetTokenResponse response = GetTokenResponse.newBuilder()
                    .setToken(token).setSignature(sigServerByteString).setHash(hashServerByteString).build();

            Timer timer = new Timer(30000, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent ae) {

                    if (getUsersMap().get(key) != null && getUsersMap().get(key).equals(token)) {
                        usersMap.replace(key, null);
                        writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);
                        System.out.println("User token expired: " + key + ":" + token);
                    }
                }
            });
            timer.setRepeats(false);
            timer.start();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/
    /*------------------------------------------------COMMANDS--------------------------------------------------------*/
    /*----------------------------------------------------------------------------------------------------------------*/
    @Override
    public synchronized void register(HelloWorld.RegisterRequest request, StreamObserver<HelloWorld.RegisterResponse> responseObserver) {
        System.out.println("Register Request Received: " + request);

        String key = request.getKey();
        /*--------------------------SIGNATURE AND HASH VALIDATE-----------------------------*/
        ByteString sigByteString = request.getSignature();
        ByteString hashByteString = request.getHash();
        String token = request.getToken();

        byte[] sig = sigByteString.toByteArray();
        byte[] hash = hashByteString.toByteArray(); //key+token

        try {
            byte[] tokenHash = Main.getHashFromObject(token);
            byte[] keyHash = Main.getHashFromObject(key);
            byte[] finalHash = ArrayUtils.addAll(keyHash, tokenHash);

            boolean valid = Main.validate(sig, key, finalHash, hash); //key == userAlias
            if(!valid){
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid signature and/or hash. Register request denied.");
                responseObserver.onError(status.asRuntimeException());
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        if (getUsersMap().get(key) != null && getUsersMap().get(key).equals(token)) {

            getUsersMap().replace(key, null);
            writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);

            System.out.println("User token expired: " + key + ":" + token);
        }

        else {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Token has already expired.");
            responseObserver.onError(status.asRuntimeException());
        }

        /*----------------------------------------------------------------------------------*/
        if (!Main.hasCertificate(key)) {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("User is not registered in keystore.");
            responseObserver.onError(status.asRuntimeException());
        }

        if (!getUsersMap().containsKey(key)) {
            getUsersMap().put(key, null);
            writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);
            System.out.println("New user registered.");
        } else
            System.out.println("User is already registered.");

        System.out.println("Users: " + getUsersMap());

        HelloWorld.RegisterResponse response = HelloWorld.RegisterResponse.newBuilder()
                .setResult(true).build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    /*--------------------------------------------------POSTS---------------------------------------------------------*/
    @Override
    public synchronized void post(PostRequest request, StreamObserver<PostResponse> responseObserver) {
        System.out.println("Post Request Received: " + request);

        Announcement post = request.getPost();
        String key = post.getKey();
        String message = post.getMessage();
        String token = request.getToken();

        if(!post.getRefList().isEmpty() && Collections.max(post.getRefList()) > getPostId()){
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Invalid reference. There is no post with that reference");
            responseObserver.onError(status.asRuntimeException());
        }

        if (message.length() > 255) {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Invalid message length. Message needs to be smaller than 255 characters.");
            responseObserver.onError(status.asRuntimeException());
        }

        if (!getUsersMap().containsKey(key)) {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("User is not registered");
            responseObserver.onError(status.asRuntimeException());
        }


        /*--------------------------SIGNATURE AND HASH VALIDATE-----------------------------*/
        ByteString sigByteString = request.getSignature();
        ByteString hashByteString = request.getHash();

        byte[] signature = sigByteString.toByteArray();
        byte[] hash = hashByteString.toByteArray(); //post+token

        try {
            byte[] tokenHash = Main.getHashFromObject(token);
            byte[] postHash = Main.getHashFromObject(post);
            byte[] finalHash = ArrayUtils.addAll(postHash, tokenHash);
            boolean valid = Main.validate(signature, key, finalHash, hash); //key == userAlias
            if(!valid){
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid signature and/or hash. Post request denied.");
                responseObserver.onError(status.asRuntimeException());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (getUsersMap().get(key) != null && getUsersMap().get(key).equals(token)) {

            getUsersMap().replace(key, null);
            writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);

            System.out.println("User token expired: " + key + ":" + token);
        }

        else {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Token has already expired.");
            responseObserver.onError(status.asRuntimeException());
        }

        /*------------------------------------POST ID---------------------------------------*/
        postId++;
        writeToFile(getPostId(), POSTID_FILE, MSG_POSTID);

        /*----------------------BUILD ANNOUNCEMENTS OF THE POST-----------------------------*/
        Announcement.Builder postBuilder = post.toBuilder();
        postBuilder.setPostId(getPostId());
        post = postBuilder.build();

        if (!getParticularMap().containsKey(key)) {
            ArrayList<Announcement> tmp = new ArrayList<Announcement>();
            tmp.add(post);
            getParticularMap().put(key, tmp);
        } else {
            ArrayList<Announcement> tmp = getParticularMap().get(key);
            tmp.add(post);
            getParticularMap().replace(key, tmp);
        }

        writeToFile(getParticularMap(), PARTICULAR_FILE, MSG_PARTICULAR);

        PostResponse response = PostResponse.newBuilder()
                .setResult(true).build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }


    @Override
    public synchronized void postGeneral(PostGeneralRequest request, StreamObserver<PostGeneralResponse> responseObserver) {
        System.out.println("Post General Request Received: " + request);

        Announcement post = request.getPost();
        String key = post.getKey();
        String message = post.getMessage();
        String token = request.getToken();


        if(!post.getRefList().isEmpty() && Collections.max(post.getRefList()) > getPostId()){
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Invalid reference. There is no post with that reference");
            responseObserver.onError(status.asRuntimeException());
        }

        if (message.length() > 255) {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Invalid message length. Message needs to be smaller than 255 characters.");
            responseObserver.onError(status.asRuntimeException());
        }

        if (!getUsersMap().containsKey(key)) {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("User is not registered");
            responseObserver.onError(status.asRuntimeException());
        }

        /*--------------------------SIGNATURE AND HASH VALIDATE-----------------------------*/
        ByteString sigByteString = request.getSignature();
        ByteString hashByteString = request.getHash();

        byte[] signature = sigByteString.toByteArray();
        byte[] hash = hashByteString.toByteArray(); //post+token

        try {
            byte[] tokenHash = Main.getHashFromObject(token);
            byte[] postHash = Main.getHashFromObject(post);
            byte[] finalHash = ArrayUtils.addAll(postHash, tokenHash);
            boolean valid = Main.validate(signature, key, finalHash, hash); //key == userAlias
            if(!valid){
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid signature and/or hash. Post General request denied.");
                responseObserver.onError(status.asRuntimeException());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (getUsersMap().get(key) != null && getUsersMap().get(key).equals(token)) {

            getUsersMap().replace(key, null);
            writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);

            System.out.println("User token expired: " + key + ":" + token);
        }

        else {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Token has already expired.");
            responseObserver.onError(status.asRuntimeException());
        }

        /*------------------------------------POST ID---------------------------------------*/
        postId++;
        writeToFile(getPostId(), POSTID_FILE, MSG_POSTID);

        /*----------------------BUILD ANNOUNCEMENTS OF THE POST-----------------------------*/
        Announcement.Builder postBuilder = post.toBuilder();
        postBuilder.setPostId(getPostId());
        post = postBuilder.build();

        getGeneralMap().add(post);

        writeToFile(getGeneralMap(), GENERAL_FILE, MSG_GENERAL);

        System.out.println("General posts: " + getGeneralMap());

        PostGeneralResponse response = PostGeneralResponse.newBuilder()
                .setResult(true).build();
        responseObserver.onNext(response);
        responseObserver.onCompleted();

    }

    /*--------------------------------------------------READS---------------------------------------------------------*/
    @Override
    public synchronized void read(ReadRequest request, StreamObserver<ReadResponse> responseObserver) {
        System.out.println("Read Request Received: " + request);

        String userAlias = request.getKey();
        String key = request.getKeyToRead();
        int number = request.getNumber();
        String token = request.getToken();

        /*--------------------------SIGNATURE AND HASH VALIDATE-----------------------------*/
        ByteString sigByteString = request.getSignature();
        ByteString hashByteString = request.getHash();

        byte[] signature = sigByteString.toByteArray();
        byte[] hash = hashByteString.toByteArray(); //userAlias+key+number+token

        try {
            byte[] tokenHash = Main.getHashFromObject(token);
            byte[] userAliasHash = Main.getHashFromObject(userAlias);
            byte[] keyHash = Main.getHashFromObject(key);
            byte[] numberHash = Main.getHashFromObject(number);
            byte[] finalHash = ArrayUtils.addAll(userAliasHash, keyHash);
            finalHash = ArrayUtils.addAll(finalHash, numberHash);
            finalHash = ArrayUtils.addAll(finalHash, tokenHash);

            boolean valid = Main.validate(signature, userAlias, finalHash, hash); //key == userAlias
            if(!valid){
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid signature and/or hash. Read request denied.");
                responseObserver.onError(status.asRuntimeException());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (getUsersMap().get(userAlias) != null && getUsersMap().get(userAlias).equals(token)) {

            getUsersMap().replace(userAlias, null);
            writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);

            System.out.println("User token expired: " + userAlias + ":" + token);
        }

        else {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Token has already expired.");
            responseObserver.onError(status.asRuntimeException());
        }

        /*----------------------------------------------------------------------------------*/
        try {
            if (number < 0) {
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid message number. Number needs to be positive.");
                responseObserver.onError(status.asRuntimeException());
            }

            if (!getParticularMap().containsKey(key)) {
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid key. There is no user with the specified key: " + key);
                responseObserver.onError(status.asRuntimeException());
            } else {
                ArrayList<Announcement> tmp = getParticularMap().get(key);
                ArrayList<Announcement> result = new ArrayList<Announcement>();

                if (number > 0) {
                    ListIterator<Announcement> listIter = tmp.listIterator(tmp.size());
                    for (int i = 0; i < number; i++) {
                        result.add(listIter.previous());
                    }
                } else {
                    Collections.reverse(tmp);
                    result.addAll(tmp);
                }

                /*--------------------------SERVER SIGNATURE AND HASH-------------------------------*/

                byte[] hashGeneral = Main.getHashFromObject(result);
                byte[] sigGeneral = Main.getSignature(hashGeneral, "server1"); //TODO change to serverAlias when we have multiple servers

                ByteString responseSigByteString = ByteString.copyFrom(sigGeneral);
                ByteString responseHashByteString = ByteString.copyFrom(hashGeneral);

                ReadResponse response = ReadResponse.newBuilder().addAllResult(result)
                        .setSignature(responseSigByteString).setHash(responseHashByteString).build();
                responseObserver.onNext(response);
            }

            responseObserver.onCompleted();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public synchronized void readGeneral(ReadGeneralRequest request, StreamObserver<ReadGeneralResponse> responseObserver) {
        System.out.println("Read General Request Received: " + request);

        String userAlias = request.getKey();
        int number = request.getNumber();
        String token = request.getToken(); //TODO: Verify tokens

        /*--------------------------SIGNATURE AND HASH VALIDATE-----------------------------*/
        ByteString sigByteString = request.getSignature();
        ByteString hashByteString = request.getHash();

        byte[] signature = sigByteString.toByteArray();
        byte[] hash = hashByteString.toByteArray(); //userAlias + number + token

        try {
            byte[] tokenHash = Main.getHashFromObject(token);
            byte[] userAliasHash = Main.getHashFromObject(userAlias);
            byte[] numberHash = Main.getHashFromObject(number);
            byte[] finalHash = ArrayUtils.addAll(userAliasHash, numberHash);
            finalHash = ArrayUtils.addAll(finalHash, tokenHash);

            boolean valid = Main.validate(signature, userAlias, finalHash, hash); //key == userAlias
            if(!valid){
                Status status = Status.INVALID_ARGUMENT;
                status = status.withDescription("Invalid signature and/or hash. Read General request denied.");
                responseObserver.onError(status.asRuntimeException());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        if (getUsersMap().get(userAlias) != null && getUsersMap().get(userAlias).equals(token)) {

            getUsersMap().replace(userAlias, null);
            writeToFile(getUsersMap(), USERS_FILE, MSG_USERS);

            System.out.println("User token expired: " + userAlias + ":" + token);
        }

        else {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Token has already expired.");
            responseObserver.onError(status.asRuntimeException());
        }

        /*----------------------------------------------------------------------------------*/

        if (number < 0) {
            Status status = Status.INVALID_ARGUMENT;
            status = status.withDescription("Invalid message number. Number needs to be positive.");
            responseObserver.onError(status.asRuntimeException());
        }

        ArrayList<HelloWorld.Announcement> general = getGeneralMap();
        ArrayList<HelloWorld.Announcement> result = new ArrayList<HelloWorld.Announcement>();

        if (number > 0) {
            ListIterator<Announcement> listIter = general.listIterator(general.size());
            for (int i = 0; i < number; i++) {
                result.add(listIter.previous());
            }

        } else {
            Collections.reverse(general);
            result.addAll(general);
        }

        /*--------------------------SERVER SIGNATURE AND HASH-------------------------------*/
        try{
            byte[] hashGeneral = Main.getHashFromObject(result);
            byte[] sigGeneral = Main.getSignature(hashGeneral, "server1"); //TODO change to serverAlias when we have multiple servers

            ByteString responseSigByteString = ByteString.copyFrom(sigGeneral);
            ByteString responseHashByteString = ByteString.copyFrom(hashGeneral);

            ReadGeneralResponse response = ReadGeneralResponse.newBuilder().addAllResult(result)
                    .setSignature(responseSigByteString).setHash(responseHashByteString).build();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
